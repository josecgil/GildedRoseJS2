"use strict";
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var sinon = require("sinon");
var chai_1 = require("chai");
var helpers = require("../../src/helpers");
var Jasmine = require("jasmine");
var JasmineTestRunner_1 = require("../../src/JasmineTestRunner");
var test_runner_1 = require("stryker-api/test_runner");
var assertions_1 = require("../helpers/assertions");
describe('JasmineTestRunner', function () {
    var sandbox;
    var jasmineStub;
    var evalGlobalStub;
    var sut;
    var fileNames;
    var clock;
    beforeEach(function () {
        sandbox = sinon.createSandbox();
        jasmineStub = sandbox.createStubInstance(Jasmine);
        jasmineStub.env = {
            throwOnExpectationFailure: sandbox.stub()
        };
        evalGlobalStub = sandbox.stub(helpers, 'evalGlobal');
        sandbox.stub(helpers, 'Jasmine').returns(jasmineStub);
        fileNames = ['foo.js', 'bar.js'];
        clock = sandbox.useFakeTimers();
        sut = new JasmineTestRunner_1.default({ fileNames: fileNames, port: 80, strykerOptions: { jasmineConfigFile: 'jasmineConfFile' } });
    });
    afterEach(function () {
        delete require.cache['foo.js'];
        delete require.cache['bar.js'];
        sandbox.restore();
    });
    it('should configure jasmine on run', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, actRunWithoutTests()];
                case 1:
                    _a.sent();
                    chai_1.expect(jasmineStub.execute).called;
                    chai_1.expect(helpers.Jasmine).calledWithNew;
                    chai_1.expect(helpers.Jasmine).calledWith({ projectBaseDir: process.cwd() });
                    chai_1.expect(jasmineStub.loadConfigFile).calledWith('jasmineConfFile');
                    chai_1.expect(jasmineStub.stopSpecOnExpectationFailure).calledWith(true);
                    chai_1.expect(jasmineStub.env.throwOnExpectationFailure).calledWith(true);
                    chai_1.expect(jasmineStub.exit).ok;
                    chai_1.expect(jasmineStub.clearReporters).called;
                    chai_1.expect(jasmineStub.randomizeTests).calledWith(false);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should clear require cache on run', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    require.cache['foo.js'] = 'foo';
                    require.cache['bar.js'] = 'bar';
                    return [4 /*yield*/, actRunWithoutTests()];
                case 1:
                    _a.sent();
                    chai_1.expect(require.cache['foo.js']).not.ok;
                    chai_1.expect(require.cache['bar.js']).not.ok;
                    return [2 /*return*/];
            }
        });
    }); });
    it('should report completed specs', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        // Arrange
        function addReporter(rep) {
            rep.specDone({ id: 'spec0', fullName: 'foo spec', status: 'success' });
            rep.specDone({ id: 'spec1', fullName: 'bar spec', status: 'failure', failedExpectations: [{ message: 'bar failed' }] });
            rep.specDone({ id: 'spec2', fullName: 'disabled', status: 'disabled' });
            rep.specDone({ id: 'spec3', fullName: 'pending', status: 'pending' });
            rep.specDone({ id: 'spec4', fullName: 'excluded', status: 'excluded' });
            rep.jasmineDone();
        }
        var result;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    jasmineStub.addReporter.callsFake(addReporter);
                    return [4 /*yield*/, sut.run({})];
                case 1:
                    result = _a.sent();
                    // Assert
                    chai_1.expect(result.status).eq(test_runner_1.RunStatus.Complete);
                    assertions_1.expectTestResultsToEqual(result.tests, [
                        { name: 'foo spec', status: test_runner_1.TestStatus.Success, failureMessages: undefined },
                        { name: 'bar spec', status: test_runner_1.TestStatus.Failed, failureMessages: ['bar failed'] },
                        { name: 'disabled', status: test_runner_1.TestStatus.Skipped, failureMessages: undefined },
                        { name: 'pending', status: test_runner_1.TestStatus.Skipped, failureMessages: undefined },
                        { name: 'excluded', status: test_runner_1.TestStatus.Skipped, failureMessages: undefined }
                    ]);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should time spec duration', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        function addReporter(rep) {
            rep.specStarted();
            clock.tick(10);
            rep.specDone({ fullName: 'foobar spec', id: 'spec0' });
            rep.jasmineDone();
        }
        var result, expectedTestResult;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    jasmineStub.addReporter.callsFake(addReporter);
                    return [4 /*yield*/, sut.run({})];
                case 1:
                    result = _a.sent();
                    expectedTestResult = {
                        name: 'foobar spec',
                        status: test_runner_1.TestStatus.Success,
                        timeSpentMs: 10,
                        failureMessages: undefined
                    };
                    chai_1.expect(result.tests).deep.eq([expectedTestResult]);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should report errors on run', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var error, result;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    error = new Error('foobar');
                    jasmineStub.execute.throws(error);
                    return [4 /*yield*/, sut.run({})];
                case 1:
                    result = _a.sent();
                    chai_1.expect(result.status).eq(test_runner_1.RunStatus.Error);
                    chai_1.expect(result.errorMessages).lengthOf(1);
                    chai_1.expect((result.errorMessages || [])[0]).matches(/An error occurred while loading your jasmine specs.*/)
                        .and.matches(/.*Error: foobar.*/);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should evaluate testHooks in global context', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var hooks;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    hooks = 'foobar';
                    return [4 /*yield*/, actRunWithoutTests(hooks)];
                case 1:
                    _a.sent();
                    chai_1.expect(evalGlobalStub).calledWith(hooks);
                    return [2 /*return*/];
            }
        });
    }); });
    function actRunWithoutTests(testHooks) {
        function addReporter(rep) {
            rep.jasmineDone();
        }
        jasmineStub.addReporter.callsFake(addReporter);
        return sut.run({ testHooks: testHooks });
    }
});
//# sourceMappingURL=JasmineTestRunnerSpec.js.map