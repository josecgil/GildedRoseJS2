"use strict";
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var path = require("path");
var chai_1 = require("chai");
var JasmineTestRunner_1 = require("../../src/JasmineTestRunner");
var test_runner_1 = require("stryker-api/test_runner");
var JasmineTestFramework_1 = require("stryker-jasmine/src/JasmineTestFramework");
var assertions_1 = require("../helpers/assertions");
function wrapInClosure(codeFragment) {
    return "\n    (function (window) {\n      " + codeFragment + "\n    })((Function('return this'))());";
}
describe('JasmineRunner integration', function () {
    var sut;
    afterEach(function () {
        process.chdir(path.resolve(__dirname, '../../..'));
    });
    describe('using the jasmine-init project', function () {
        var expectedJasmineInitResults = Object.freeze([Object.freeze({
                name: 'Player should be able to play a Song',
                status: test_runner_1.TestStatus.Success,
                failureMessages: undefined
            }), Object.freeze({
                name: 'Player when song has been paused should indicate that the song is currently paused',
                status: test_runner_1.TestStatus.Success,
                failureMessages: undefined
            }), Object.freeze({
                name: 'Player when song has been paused should be possible to resume',
                status: test_runner_1.TestStatus.Success,
                failureMessages: undefined
            }), Object.freeze({
                name: 'Player tells the current song if the user has made it a favorite',
                status: test_runner_1.TestStatus.Success,
                failureMessages: undefined
            }), Object.freeze({
                name: 'Player #resume should throw an exception if song is already playing',
                status: test_runner_1.TestStatus.Success,
                failureMessages: undefined
            })]);
        beforeEach(function () {
            process.chdir(path.resolve(__dirname, '../../testResources/jasmine-init'));
            sut = new JasmineTestRunner_1.default({
                fileNames: [
                    path.resolve('lib', 'jasmine_examples', 'Player.js'),
                    path.resolve('lib', 'jasmine_examples', 'Song.js'),
                    path.resolve('spec', 'helpers', 'jasmine_examples', 'SpecHelper.js'),
                    path.resolve('spec', 'jasmine_examples', 'PlayerSpec.js')
                ],
                port: 80,
                strykerOptions: { jasmineConfigFile: 'spec/support/jasmine.json' }
            });
        });
        it('should run the specs', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var runResult;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sut.run({})];
                    case 1:
                        runResult = _a.sent();
                        chai_1.expect(runResult.status).eq(test_runner_1.RunStatus.Complete);
                        assertions_1.expectTestResultsToEqual(runResult.tests, expectedJasmineInitResults);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should be able to run twice in short succession', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var secondRunResult;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sut.run({})];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, sut.run({})];
                    case 2:
                        secondRunResult = _a.sent();
                        chai_1.expect(secondRunResult.status).eq(test_runner_1.RunStatus.Complete);
                        assertions_1.expectTestResultsToEqual(secondRunResult.tests, expectedJasmineInitResults);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should be able to filter tests', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var testFramework, testHooks, runResult;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        testFramework = new JasmineTestFramework_1.default();
                        testHooks = wrapInClosure(testFramework.filter([{
                                name: expectedJasmineInitResults[1].name,
                                id: 1
                            }, {
                                name: expectedJasmineInitResults[3].name,
                                id: 3
                            }]));
                        return [4 /*yield*/, sut.run({ testHooks: testHooks })];
                    case 1:
                        runResult = _a.sent();
                        // Assert
                        chai_1.expect(runResult.status).eq(test_runner_1.RunStatus.Complete);
                        expectTestsFiltered(runResult.tests, 1, 3);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should be able to filter tests in quick succession', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var testFramework, testHooks1, testHooks2, firstResult, secondResult;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        testFramework = new JasmineTestFramework_1.default();
                        testHooks1 = wrapInClosure(testFramework.filter([{
                                name: expectedJasmineInitResults[1].name,
                                id: 1
                            }]));
                        testHooks2 = wrapInClosure(testFramework.filter([{
                                name: expectedJasmineInitResults[2].name,
                                id: 2
                            }]));
                        return [4 /*yield*/, sut.run({ testHooks: testHooks1 })];
                    case 1:
                        firstResult = _a.sent();
                        return [4 /*yield*/, sut.run({ testHooks: testHooks2 })];
                    case 2:
                        secondResult = _a.sent();
                        // Assert
                        expectTestsFiltered(firstResult.tests, 1);
                        expectTestsFiltered(secondResult.tests, 2);
                        return [2 /*return*/];
                }
            });
        }); });
        function expectTestsFiltered(actualTestResults) {
            var filteredTestIds = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                filteredTestIds[_i - 1] = arguments[_i];
            }
            assertions_1.expectTestResultsToEqual(actualTestResults, expectedJasmineInitResults.map(function (testResult, id) { return ({
                name: testResult.name,
                status: filteredTestIds.indexOf(id) >= 0 ? test_runner_1.TestStatus.Success : test_runner_1.TestStatus.Skipped,
                failureMessages: testResult.failureMessages
            }); }));
        }
    });
    describe('using a jasmine-project with errors', function () {
        beforeEach(function () {
            process.chdir(path.resolve(__dirname, '../../testResources/errors'));
            sut = new JasmineTestRunner_1.default({
                fileNames: [path.resolve('lib', 'error.js'),
                    path.resolve('spec', 'errorSpec.js')
                ], port: 80, strykerOptions: {}
            });
        });
        it('should be able to tell the error', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var result, actualError;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sut.run({})];
                    case 1:
                        result = _a.sent();
                        chai_1.expect(result.status).eq(test_runner_1.RunStatus.Error);
                        chai_1.expect(result.errorMessages).lengthOf(1);
                        actualError = result.errorMessages[0];
                        chai_1.expect(actualError)
                            .matches(/^An error occurred while loading your jasmine specs.*/)
                            .matches(/.*SyntaxError: Unexpected identifier.*/);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('when it includes failed tests', function () {
        beforeEach(function () {
            process.chdir(path.resolve(__dirname, '../../testResources/test-failures'));
            sut = new JasmineTestRunner_1.default({
                fileNames: [
                    path.resolve('lib', 'foo.js'),
                    path.resolve('spec', 'fooSpec.js')
                ], port: 80, strykerOptions: {}
            });
        });
        it('should complete with one test failure', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sut.run({})];
                    case 1:
                        result = _a.sent();
                        chai_1.expect(result.status).eq(test_runner_1.RunStatus.Complete);
                        assertions_1.expectTestResultsToEqual(result.tests, [{
                                name: 'foo should be baz',
                                status: test_runner_1.TestStatus.Failed,
                                failureMessages: ['Expected \'bar\' to be \'baz\'.']
                            }]);
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
//# sourceMappingURL=JasmineRunner.it.js.map